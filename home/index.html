<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./style.css">
    <script type="text/javascript" href="./booklibrary.js" defer></script>
    <title>Book Library</title>
</head>
<body>
    
    <div class="content">
        <div class="main_content">
            <div class="herogallery">
                <div id="main_hg_title"></div>
                <div id="hg_card_style">
                    <div class="hg_card">
                        <img class="hg_img" src="Icon_18-512.png" style="width: 100px; height: 100px;">
                        <div class="hg_text">book placeholder</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script defer>

        /*Recommended Method for Prototypal Inheritance

        function Student() {
        }

        Student.prototype.sayName = function() {
            console.log(this.name)
        }

        At this point in history, the recommended way of 
        setting the prototype of an object is Object.create.

        Object.create very simply returns a new object with 
        the specified prototype and any additional properties you want to add.

        function EighthGrader(name) {
            this.name = name
            this.grade = 8
        }

        EighthGrader.prototype = Object.create(Student.prototype)

        const carl = new EighthGrader("carl")
        carl.sayName() // console.logs "carl"
        carl.grade // 8

        After creating the constructor for EighthGrader, 
        we set its prototype to a new object that has a copy of Student.prototype.

        End Example*/

        //Book Constructor

    let myLibrary = [];

    function book(title, author, pageCount, readStatus) {
        this.title = title
        this.author = author
        this.pageCount = pageCount
        this.readStatus = readStatus

        /*this.info = function() {
            console.log(title + ' by ' + author + ', ' + pageCount + ', ' + readStatus);
        }*/
    }
    book.prototype.info = function() {
        console.log(this.title + ' by ' + this.author + ', ' + this.pageCount + ', ' + this.readStatus);
    }

    function addBookToLibrary() {
        //Do Stuff
    }

    

    /* 
        If your methods do not use local variables defined in your constructor (your example doesn't), then use the prototype approach.

        If you're creating lots of (books), use the prototype approach. 
        This way, all "instances" (i.e. objects created by the book constructor) will share one set of functions, 
        whereas the constructor way, a new set of functions is created every time the book constructor is called, using more memory.

        If you're creating a small number of books and find that using local, "private" variables in your constructor improves your code, 
        this may be the better approach. Use your judgment and do some benchmarks if performance or memory consumption are major concerns.
    */

    </script>

</body>
</html>